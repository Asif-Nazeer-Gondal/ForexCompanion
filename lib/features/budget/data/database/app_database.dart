import 'dart:io';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;

import 'package:forex_companion/features/budget/data/database/tables.dart';

// This tells Drift to look for the generated file
part 'app_database.g.dart';

/// Returns the path to the application's budget database file.
// FIX: Correct signature uses 'get' to define an async getter.
Future<File> get databaseFile async {
  final appDir = await getApplicationDocumentsDirectory();
  final dbPath = p.join(appDir.path, 'budget_companion.sqlite');
  return File(dbPath);
}

/// The main database class for the budget feature, generated by Drift.
@DriftDatabase(tables: [BudgetEntries])
// FIX: Correctly extends the generated class.
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());

  // FIX: This override is correct because _$AppDatabase inherits from a class that defines it.
  @override
  int get schemaVersion => 1;

  // Query: Reactive stream of all entries, ordered by date
  Stream<List<BudgetEntry>> watchAllEntries() {
    // FIX: These methods are now accessible via inheritance from _$AppDatabase
    return (select(budgetEntries)..orderBy([(t) => OrderingTerm.desc(t.date)]))
        .watch();
  }

  // Query: Insert a new entry
  Future<int> insertEntry(BudgetEntriesCompanion entry) =>
      into(budgetEntries).insert(entry);

  // Query: Delete an entry by ID
  Future<void> deleteEntry(int id) =>
      (delete(budgetEntries)..where((tbl) => tbl.id.equals(id))).go();
}

/// Helper function to establish the database connection
LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final file = await databaseFile; // Uses the corrected async getter above
    return NativeDatabase(file);
  });
}
